## utility function that converts english type to greek text 

**map english characters to Greek characters:**
each english language character needs to correspond to a unicode value 
the mapping can be done with an Object literal, e.g, `alpha` is:   
```js 
    {
        'a': 945
    }
```
A very basic mapping function would look like this:
```js 

    let e2gMap = { 'a': 945, 'b': 946, 'c': 947 };

    const e2gMapper = ch => String.fromCharCode(e2gMap[ch]);

```

What about the object that will have all the values together?
```js 

    {
        'A': 913, // ALPHA
        'B': 914, // BETA
        'G': 915, // GAMMA
        'D': 916, // DELTA
        'E': 917, // EPSILON
        'Z': 918, // ZETA
        'EE': 919, // ETA
        'TH': 920, // THETA
        'I': 921, // IOTA 
        'K': 922, // KAPPA
        'L': 923, // LAMBDA
        'M': 924, // MU
        'N': 925, // NU
        'X': 926, // XI
        'O': 927, // OMICRON
        'P': 928, // PI
        'R': 929, // RHO
        '': 930, // ?????????????
        'S': 931, // SIGMA 
        'T': 932, // TAO
        'U': 933, // UPSILON
        'PH': 934, // PHI
        'CH': 935, // CHI
        'PS': 936, // PSI
        'OO': 937, // OMEGA
        '': 938, // vv accented characters vv //
        '': 939,
        '': 940,
        '': 941,
        '': 942,
        '': 943,
        '': 944, // ^^ accented characters ^^ // 
        'a': 945, // alpha
        'b': 946, // beta
        'g': 947, // gamma
        'd': 948, // delta
        'e': 949, // epsilon
        'z': 950, // zeta
        'ee': 951, // eta
        'th': 952, // theta
        'i': 953, // iota
        'k': 954, // kappa
        'l': 955, // lambda
        'm': 956, // mu
        'n': 957, // nu
        'x': 958, // xi 
        'o': 959, // omicron
        'p': 960, // pi
        'r': 961, // rho
        's ': 962, // end-sigma // check to see if it is followed by a whitespace
        's': 963, // sigma 
        't': 964, // tao
        'u': 965, // upsilon
        'ph': 966, // phi
        'ch': 967, // chi
        'ps': 968, // psi 
        'oo': 969, // omega 
        '': 970, // vv accents and others (e.g., around 990 digamma) vv //
        '': 971,
        '': 972,
        '': 973,
        '': 974,
        '': 975,
        '': 976,
        '': 977,
        '': 978,
        '': 979,
        '': 980,
        '': 981,
    }

```

But how do we go about parsing the text? 

We can convert whole words with something like:
```js 

    function convert(str) {
      return str.split('').map(ch => {
        let uni = lexicon[ch];
        return String.fromCharCode(uni);
      }).join('')
    }

```

So, one option is to wait for whole words to be written. We load up the state with a temporary word and when the space bar is hit it triggers a new event which causes the whole word to be passed to that function and the space on the state to be whiped clean. that is not real-time transcription, however. And to do that we need to have some kind of helping functions...

In the React component we could have an if statement, something that takes a call back. Some kind of trigger. A function that holds information and invokes something only when... or we could use closure. like a special character flag.

## utility function that parses the text 

## utility function that inserts dots between the terms 

## utility function that shows the stresses for each syllable 
