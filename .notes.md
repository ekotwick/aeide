## utility function that converts english type to greek text 

**map english characters to Greek characters:**
each english language character needs to correspond to a unicode value 
the mapping can be done with an Object literal, e.g, `alpha` is:   
```js 
    {
        'a': 945
    }
```
A very basic mapping function would look like this:
```js 

    let e2gMap = { 'a': 945, 'b': 946, 'c': 947 };

    const e2gMapper = ch => String.fromCharCode(e2gMap[ch]);

```

What about the object that will have all the values together?

FOR TRANSLITERATING

```js 

    {
        'A': 913, // ALPHA
        'B': 914, // BETA
        'G': 915, // GAMMA
        'D': 916, // DELTA
        'E': 917, // EPSILON
        'Z': 918, // ZETA
        'EE': 919, // ETA
        'TH': 920, // THETA
        'I': 921, // IOTA 
        'K': 922, // KAPPA
        'L': 923, // LAMBDA
        'M': 924, // MU
        'N': 925, // NU
        'X': 926, // XI
        'O': 927, // OMICRON
        'P': 928, // PI
        'R': 929, // RHO
        '': 930, // ?????????????
        'S': 931, // SIGMA 
        'T': 932, // TAO
        'U': 933, // UPSILON
        'PH': 934, // PHI
        'CH': 935, // CHI
        'PS': 936, // PSI
        'OO': 937, // OMEGA
        '': 938, // vv accented characters vv //
        '': 939,
        '': 940,
        '': 941,
        '': 942,
        '': 943,
        '': 944, // ^^ accented characters ^^ // 
        'a': 945, // alpha
        'b': 946, // beta
        'g': 947, // gamma
        'd': 948, // delta
        'e': 949, // epsilon
        'z': 950, // zeta
        'ee': 951, // eta
        'th': 952, // theta
        'i': 953, // iota
        'k': 954, // kappa
        'l': 955, // lambda
        'm': 956, // mu
        'n': 957, // nu
        'x': 958, // xi 
        'o': 959, // omicron
        'p': 960, // pi
        'r': 961, // rho
        's ': 962, // end-sigma // check to see if it is followed by a whitespace
        's': 963, // sigma 
        't': 964, // tao
        'u': 965, // upsilon
        'ph': 966, // phi
        'ch': 967, // chi
        'ps': 968, // psi 
        'oo': 969, // omega 
        '': 970, // vv accents and others (e.g., around 990 digamma) vv //
        '': 971,
        '': 972,
        '': 973,
        '': 974,
        '': 975,
        '': 976,
        '': 977,
        '': 978,
        '': 979,
        '': 980,
        '': 981,
    }

```

MAKE FOR STANDARD UNICODE
```js 

    {
        'A': 913, // ALPHA
        'B': 914, // BETA
        'G': 915, // GAMMA
        'D': 916, // DELTA
        'E': 917, // EPSILON
        'Z': 918, // ZETA
        'H': 919, // ETA
        'U': 920, // THETA
        'I': 921, // IOTA 
        'K': 922, // KAPPA
        'L': 923, // LAMBDA
        'M': 924, // MU
        'N': 925, // NU
        'J': 926, // XI
        'O': 927, // OMICRON
        'P': 928, // PI
        'R': 929, // RHO
        '': 930, // ?????????????
        'S': 931, // SIGMA 
        'T': 932, // TAO
        'U': 933, // UPSILON
        'F': 934, // PHI
        'X': 935, // CHI
        'C': 936, // PSI
        'OO': 937, // OMEGA
        '': 938, // vv accented characters vv //
        '': 939,
        '': 940,
        '': 941,
        '': 942,
        '': 943,
        '': 944, // ^^ accented characters ^^ // 
        'a': 945, // alpha
        'b': 946, // beta
        'g': 947, // gamma
        'd': 948, // delta
        'e': 949, // epsilon
        'z': 950, // zeta
        'ee': 951, // eta
        'th': 952, // theta
        'i': 953, // iota
        'k': 954, // kappa
        'l': 955, // lambda
        'm': 956, // mu
        'n': 957, // nu
        'x': 958, // xi 
        'o': 959, // omicron
        'p': 960, // pi
        'r': 961, // rho
        's ': 962, // end-sigma // check to see if it is followed by a whitespace
        's': 963, // sigma 
        't': 964, // tao
        'u': 965, // upsilon
        'ph': 966, // phi
        'ch': 967, // chi
        'ps': 968, // psi 
        'oo': 969, // omega 
        '': 970, // vv accents and others (e.g., around 990 digamma) vv //
        '': 971,
        '': 972,
        '': 973,
        '': 974,
        '': 975,
        '': 976,
        '': 977,
        '': 978,
        '': 979,
        '': 980,
        '': 981,
    }

```

UNICODE HEXIDECIMAL CODING:
```js 

    const engToGrk = {
        ' ': '\u0020', // white space
        '.': '\u002E', // period 
        ',': '\u0326', // comma 
        '•': '\u2022', // colon
        ';': '', // semi-colon
        '⁓': '\u2053', // spacer for syllables?
        'a': '\u03B1', // alpha
        'b': '\u03B2', // beta
        'g': '\u03B3', // gamma 
        'd': '\u03B4', // delta 
        'e': '\u03B5', // epsiolon
        'z': '\u03B6', // zeta
        'h': '\u03B7', // eta 
        'q': '\u03B8', // theta 
        'i': '\u03B9', // iota  
        'k': '\u03BA', // kappa 
        'l': '\u03BB', // lamba 
        'm': '\u03BC', // mu 
        'n': '\u03BD', // nu  
        'x': '\u03BE', // xi 
        'o': '\u03BF', // omicron 
        'p': '\u03C0', // pi
        'r': '\u03C1', // rho
        's': '\u03C2', // sigma (end)
        'c': '\u03C3', // sigma (middle)
        't': '\u03C4', // tao
        'y': '\u03C5', // upsilon
        'f': '\u03C6', // phi
        'v': '\u03C7', // chi 
        'j': '\u03C8', // psi 
        'w': '\u03C9', // omega
    }

```

But how do we go about parsing the text? 

We can convert whole words with something like:
```js 

    function convert(str) {
      return str.split('').map(ch => {
        let uni = lexicon[ch];
        return String.fromCharCode(uni);
      }).join('')
    }

```

So, one option is to wait for whole words to be written. We load up the state with a temporary word and when the space bar is hit it triggers a new event which causes the whole word to be passed to that function and the space on the state to be whiped clean. that is not real-time transcription, however. And to do that we need to have some kind of helping functions...

In the React component we could have an if statement, something that takes a call back. Some kind of trigger. A function that holds information and invokes something only when... or we could use closure. like a special character flag.

// need to have a special case for Homeric Greek.

ECMAScript 5 sucked when it came to handling unicode values. The function `String.fromCharCode` sucks balls and doesn't write Greek.
The ECMAScript 6 function `String.fromCodePoint` improves on this. That, or use a library to fix it:
https://mathiasbynens.be/notes/javascript-unicode
https://github.com/bestiejs/punycode.js     

For typing Greek:
http://greek.typeit.org/

http://www.lexilogos.com/keyboard/greek_ancient.htm

http://sites.psu.edu/symbolcodes/languages/ancient/greek/greekchart/
http://ascii-table.com/html-table-greek-letters.php 

If we wanted to map English characters to Greek, we might do something like this:
```js

    const toConvert = str => {
      let toLog = str.split('').map(ch => engToGrk[ch]).join('');
      console.log(toLog);
    }

    let test = "menin aeide thea"
    // => μενιν αειδε τηεα

```

Now we have to devise the parsing function:

But what we need to test: if it's a vowel or whitepsace... so the object is smaller

```js 

    const greekVowels = {
        'a': '\u03B1', // alpha
        'e': '\u03B5', // epsiolon
        'h': '\u03B7', // eta 
        'i': '\u03B9', // iota  
        'o': '\u03BF', // omicron 
        'w': '\u03C9', // omega
    };

    const greekConstants = {
        'b': '\u03B2', // beta
        'g': '\u03B3', // gamma 
        'd': '\u03B4', // delta 
        'z': '\u03B6', // zeta
        'q': '\u03B8', // theta 
        'k': '\u03BA', // kappa 
        'l': '\u03BB', // lamba 
        'm': '\u03BC', // mu 
        'n': '\u03BD', // nu  
        'x': '\u03BE', // xi 
        'p': '\u03C0', // pi
        'r': '\u03C1', // rho
        's': '\u03C2', // sigma (end)
        'c': '\u03C3', // sigma (middle)
        't': '\u03C4', // tao
        'f': '\u03C6', // phi
        'v': '\u03C7', // chi 
        'j': '\u03C8', // psi 
        'w': '\u03C9', // omega
    }



```

no: it wouldn't make sense to do that... it would make more sense to search for consonants....
we have to iterate through each term and check to see what follows it

The parse can look like this:

```js 

    const parser = str => {
        let parsed = '';

        let index = 0;
        while (index < str.length) {
            let i = index;

            if (str[i] === '\u0020') continue; // if whitespace
            
            if (str[i] === '\u03B1' || str[i] === '\u03B5' || str[i] === '\u03BF') { // if can be dipthong
                let dipthong = dipthongify(str[i], str[i+1])
                parsed += dipthong[0]; // returns vowel or dipthong
                i += dipthong[1]; // incredments index accordingly
            } else if (str[i] === '\u03B7' || str[i] === '\u03B9'|| str[i] === '\u03C9') { // if vowel that can't be a dipthong
                parsed += str[i];
                i += 1;
            }

            // check the consonants: keep in an if statement
            if (str[i] === '\u0020') {
                i += 1;
                let consonants = consonantsify(str[i], str[i+1])
                parsed += consonants[0];
                i += consonants[1]
            } else {
                let consonants = consonantsify(str[i], str[i+1])
                parsed += consonants[0];
                i += consonants[1]
            }

            parsed += '\u2022';
            index += i;
        };
        return parsed;
    }

```

## utility function that parses the text 

## utility function that inserts dots between the terms 

## utility function that shows the stresses for each syllable 
